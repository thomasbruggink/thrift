/**
 * Autogenerated by Thrift Compiler (0.15.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.testing.api;

@javax.annotation.processing.Generated(value = ["Autogenerated by Thrift Compiler (0.15.0)"], date = "2021-07-11")
class MyTestService {

  interface Iface {

    @Throws(org.apache.thrift.TException::class, unsupportedName::class)
    fun testMethod(req:testOneRequest?):testOneResponse

  }

  interface AsyncIface {

    @Throws(org.apache.thrift.TException::class, unsupportedName::class)
    suspend fun testMethod(req:testOneRequest?):testOneResponse

  }

  class Client(
      inputProtocol: org.apache.thrift.protocol.TProtocol,
      outputProtocol : org.apache.thrift.protocol.TProtocol 
  ) : org.apache.thrift.TServiceClient(inputProtocol, outputProtocol), Iface {
    constructor(prot:org.apache.thrift.protocol.TProtocol): this(prot, prot)

    companion object {
      class Factory : org.apache.thrift.TServiceClientFactory<Client> {
        override fun getClient(prot: org.apache.thrift.protocol.TProtocol):Client {
          return Client(prot)
        }
        override fun getClient(iprot: org.apache.thrift.protocol.TProtocol, oprot: org.apache.thrift.protocol.TProtocol):Client {
          return Client(iprot, oprot)
        }
      }
    }
    @Throws(org.apache.thrift.TException::class, unsupportedName::class)
    override fun testMethod(req:testOneRequest?):testOneResponse
    {
      sendTestMethod(req)
      return recvTestMethod()
    }

    @Throws(org.apache.thrift.TException::class)
    fun sendTestMethod(req:testOneRequest?)
    {
      val args:testMethod_args = testMethod_args()
      args.setReq(req)
      sendBase("testMethod", args)
    }

    @Throws(org.apache.thrift.TException::class, unsupportedName::class)
    fun recvTestMethod():testOneResponse
    {
      val result:testMethod_result = testMethod_result()
      receiveBase(result, "testMethod")
      if (result.isSetSuccess()) {
         return result.getSuccess()!!
      }
      if (result.isSetError()) {
        throw result.getError()!!
      }
      throw org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "testMethod failed: unknown result")
    }

  }
  class AsyncClient(
      inputProtocol: org.apache.thrift.protocol.TProtocol,
      outputProtocol: org.apache.thrift.protocol.TProtocol 
  ) : org.apache.thrift.TAsyncClient(inputProtocol, outputProtocol), AsyncIface {
    constructor(prot: org.apache.thrift.protocol.TProtocol): this(prot, prot)

    companion object {
      class Factory : org.apache.thrift.TServiceClientFactory<AsyncClient> {
        override fun getClient(prot: org.apache.thrift.protocol.TProtocol):AsyncClient {
          return AsyncClient(prot)
        }
        override fun getClient(iprot: org.apache.thrift.protocol.TProtocol, oprot: org.apache.thrift.protocol.TProtocol):AsyncClient {
          return AsyncClient(iprot, oprot)
        }
      }
    }
    @Throws(org.apache.thrift.TException::class, unsupportedName::class)
    override suspend fun testMethod(req:testOneRequest?):testOneResponse
    {
      sendTestMethod(req)
      return recvTestMethod()
    }

    @Throws(org.apache.thrift.TException::class)
    suspend fun sendTestMethod(req:testOneRequest?)
    {
      val args:testMethod_args = testMethod_args()
      args.setReq(req)
      sendBase("testMethod", args)
    }

    @Throws(org.apache.thrift.TException::class, unsupportedName::class)
    suspend fun recvTestMethod():testOneResponse
    {
      val result:testMethod_result = testMethod_result()
      receiveBase(result, "testMethod")
      if (result.isSetSuccess()) {
        return result.getSuccess()!!
      }
      if (result.isSetError()) {
        throw result.getError()!!
      }
      throw org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "testMethod failed: unknown result")
    }

  }
  class Processor(
    iface:Iface,
    processMap:Map<String, org.apache.thrift.ProcessFunction<Iface, out org.apache.thrift.TBase<*, *>>>
  ): org.apache.thrift.TBaseProcessor<Iface>(iface, processMap), org.apache.thrift.TProcessor {
    constructor(iface:Iface): this(iface, getProcessMap(mutableMapOf<String, org.apache.thrift.ProcessFunction<Iface, out org.apache.thrift.TBase<*, *>>>()))

    companion object {
      fun getProcessMap(processMap: MutableMap<String, org.apache.thrift.ProcessFunction<Iface, out org.apache.thrift.TBase<*, *>>>): Map<String, org.apache.thrift.ProcessFunction<Iface, out org.apache.thrift.TBase<*, *>>> {
        processMap["testMethod"] = testMethod()
        return processMap.toMap()
      }

      class testMethod: org.apache.thrift.ProcessFunction<Iface, testMethod_args>("testMethod") {
        override val emptyArgsInstance: testMethod_args
          get() = testMethod_args()
        override val isOneway: Boolean
          get() = false
        override fun rethrowUnhandledExceptions(): Boolean {
          return true
        }

        @Throws(org.apache.thrift.TException::class)
        override fun getResult(iface: Iface, args:testMethod_args): testMethod_result {
          val result: testMethod_result = testMethod_result()
          try {
            result.setSuccess(iface.testMethod(args.getReq()))
          } catch (error: unsupportedName) {
            result.setError(error)
          }
          return result
        }
      }
    }
  }

  class AsyncProcessor(
    iface:AsyncIface,
    processMap:Map<String, org.apache.thrift.AsyncProcessFunction<AsyncIface, out org.apache.thrift.TBase<*, *>>>
  ): org.apache.thrift.TAsyncBaseProcessor<AsyncIface>(iface, processMap), org.apache.thrift.TProcessor {
    constructor(iface:AsyncIface): this(iface, getProcessMap(mutableMapOf<String, org.apache.thrift.AsyncProcessFunction<AsyncIface, out org.apache.thrift.TBase<*, *>>>()))

    companion object {
      fun getProcessMap(processMap: MutableMap<String, org.apache.thrift.AsyncProcessFunction<AsyncIface, out org.apache.thrift.TBase<*, *>>>): Map<String, org.apache.thrift.AsyncProcessFunction<AsyncIface, out org.apache.thrift.TBase<*, *>>> {
        processMap["testMethod"] = testMethod()
        return processMap.toMap()
      }

      class testMethod: org.apache.thrift.AsyncProcessFunction<AsyncIface, testMethod_args>("testMethod") {
        override val emptyArgsInstance: testMethod_args
          get() = testMethod_args()
        override val isOneway: Boolean
          get() = false
        override fun rethrowUnhandledExceptions(): Boolean {
          return true
        }

        @Throws(org.apache.thrift.TException::class)
        override suspend fun getResult(iface: AsyncIface, args:testMethod_args): testMethod_result {
          val result: testMethod_result = testMethod_result()
          try {
            result.setSuccess(iface.testMethod(args.getReq()))
          } catch (error: unsupportedName) {
            result.setError(error)
          }
          return result
        }
      }
    }
  }

  class testMethod_args( 
    private var req: testOneRequest? = testOneRequest() // required
): org.apache.thrift.TBase<testMethod_args, testMethod_args.Fields>, java.io.Serializable, Cloneable, Comparable<testMethod_args>   {

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    enum class Fields(
      override val thriftFieldId: Short,
      override val fieldName: String
    ) : org.apache.thrift.TFieldIdEnum {
      REQ(1, "req");

      companion object {
        var byName: Map<String, Fields> = mapOf(
          "req" to REQ
        )
        /**
         * Find the Fields constant that matches fieldId, or null if its not found.
         */
        fun findByThriftId(fieldId: Short): Fields? {
          return when(fieldId) {
            (1).toShort() -> // REQ
              REQ
            else ->
              null
          }
        }

        /**
         * Find the Fields constant that matches fieldId, throwing an exception
         * if it is not found.
         */
        fun findByThriftIdOrThrow(fieldId: Short): Fields {
          return findByThriftId(fieldId)
            ?: throw java.lang.IllegalArgumentException("Field $fieldId doesn't exist!");
        }

        /**
         * Find the Fields constant that matches name, or null if its not found.
         */
        fun findByName(name: String): Fields? {
          return byName.get(name)
        }
      }
    }

      private val metaDataMap: Map<Fields, org.apache.thrift.meta_data.FieldMetaData> = mapOf(
        Fields.REQ to org.apache.thrift.meta_data.FieldMetaData("req", org.apache.thrift.TFieldRequirementType.DEFAULT, 
            org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, testOneRequest::class.java)))
      init {
        org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(testMethod_args::class.java, metaDataMap)
      }
    /**
     * Performs a deep copy on <i>other</i>.
     */
    constructor(other: testMethod_args) : this() {
      if (other.isSetReq()) {
        this.req = testOneRequest(other.req!!)
      }
    }

    override fun deepCopy(): testMethod_args{
      return testMethod_args(this)
    }

    override fun clear() {
      this.req?.clear()
    }

    fun getReq():testOneRequest? {
      return this.req
    }

    fun setReq(req: testOneRequest?): testMethod_args {
      this.req = req
      return this
    }

    fun unsetReq() {
      this.req = null
    }

    /** Returns true if field req is set (has been assigned a value) and false otherwise */
    fun isSetReq(): Boolean {
      return this.req != null
    }

    fun setReqIsSet(value: Boolean) {
      if (!value) {
        this.req = null
      }
    }

    override fun setFieldValue(field: Fields,  value: Any?) {
        when (field) {
      Fields.REQ ->
        if (value == null) {
          unsetReq()
        } else {
          setReq(value as testOneRequest)
        }

        }
    }

    override fun getFieldValue(field: Fields): Any? {
      return when(field) {
        Fields.REQ -> getReq()
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    override fun isSet(field: Fields): Boolean {
      return when (field) {
        Fields.REQ->isSetReq()
      }
    }

    override fun equals(other: Any?): Boolean {
      if (other is testMethod_args)
            return this.equals(other)
      return false
    }

    fun equals(other: testMethod_args?):Boolean {
      if (other == null)
        return false
      if (this == other)
        return true

      val this_present_req: Boolean = true && this.isSetReq()
      val other_present_req: Boolean = true && other.isSetReq()
      if (this_present_req || other_present_req) {
        if (!(this_present_req && other_present_req))
          return false;
        if (!this.req!!.equals(other.req))
          return false;
      }

      return true;
    }

    override fun hashCode():Int {
      var hashCode: Int = 1

      hashCode = hashCode * 8191 + (if(isSetReq()) 131071 else 524287)
      if (isSetReq())
        hashCode = hashCode * 8191 + req.hashCode()

      return hashCode
    }

    override fun compareTo(other: testMethod_args):Int {
      if (!javaClass.equals(other.javaClass)) {
        return javaClass.getName().compareTo(other.javaClass.getName())
      }

      var lastComparison:Int = 0

      lastComparison = java.lang.Boolean.compare(isSetReq(), other.isSetReq());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetReq()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.req, other.req);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    override fun fieldForId(fieldId: Short):Fields? {
      return Fields.findByThriftId(fieldId)
    }

    override suspend fun read(iprot: org.apache.thrift.protocol.TProtocol) {
      scheme<testMethod_args>(iprot).read(iprot, this)
    }

    override suspend fun write(oprot: org.apache.thrift.protocol.TProtocol) {
      scheme<testMethod_args>(oprot).write(oprot, this)
    }

    override fun toString():String {
      val sb:java.lang.StringBuilder = java.lang.StringBuilder("testMethod_args(")
      var first:Boolean = true

      sb.append("req:")
      if (this.req == null) {
        sb.append("null")
      } else {
        sb.append(this.req)
      }
      first = false
      sb.append(")");
      return sb.toString()
    }

    fun validate() {
      // check for required fields
      // check for sub-struct validity
      req?.validate();
    }

    suspend fun writeObject(out:java.nio.channels.AsynchronousByteChannel) {
      try {
        write(org.apache.thrift.protocol.TCompactProtocol(org.apache.thrift.transport.TIOStreamTransport(out)))
      } catch (te:org.apache.thrift.TException) {
        throw java.io.IOException(te);
      }
    }

    suspend fun readObject(inp:java.nio.channels.AsynchronousByteChannel) {
      try {
        read(org.apache.thrift.protocol.TCompactProtocol(org.apache.thrift.transport.TIOStreamTransport(inp)))
      } catch (te:org.apache.thrift.TException) {
        throw java.io.IOException(te);
      }
    }

    private class testMethod_argsStandardSchemeFactory : org.apache.thrift.scheme.SchemeFactory<testMethod_argsStandardScheme> {
      override fun getScheme():testMethod_argsStandardScheme {
        return testMethod_argsStandardScheme()
      }
    }

    private class testMethod_argsStandardScheme : org.apache.thrift.scheme.StandardScheme<testMethod_args>() {

      override suspend fun read(iprot:org.apache.thrift.protocol.TProtocol, struct:testMethod_args) {
        lateinit var schemeField: org.apache.thrift.protocol.TField
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin()
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break
          }
          when (schemeField.id.toInt()) {
            1 -> // REQ
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.req = testOneRequest()
                struct.req?.read(iprot)
                struct.setReqIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
            else ->
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      override suspend fun write(oprot:org.apache.thrift.protocol.TProtocol, struct:testMethod_args) {
        struct.validate()

        oprot.writeStructBegin(STRUCT_DESC)
        if (struct.req != null) {
          oprot.writeFieldBegin(REQ_FIELD_DESC)
          struct.req?.write(oprot);
          oprot.writeFieldEnd()
        }
        oprot.writeFieldStop()
        oprot.writeStructEnd()
      }

    }

    private class testMethod_argsTupleSchemeFactory : org.apache.thrift.scheme.SchemeFactory<testMethod_argsTupleScheme> {
      override fun getScheme():testMethod_argsTupleScheme {
        return testMethod_argsTupleScheme()
      }
    }

    private class testMethod_argsTupleScheme : org.apache.thrift.scheme.TupleScheme<testMethod_args>() {

      override suspend fun write(oprot:org.apache.thrift.protocol.TProtocol, struct:testMethod_args) {
        val prot:org.apache.thrift.protocol.TTupleProtocol = oprot as org.apache.thrift.protocol.TTupleProtocol
        val optionals:java.util.BitSet = java.util.BitSet()
        if (struct.isSetReq()) {
          optionals.set(0)
        }
        prot.writeBitSet(optionals, 1)
        if (struct.isSetReq()) {
          struct.req?.write(oprot);
        }
      }

      override suspend fun read(iprot: org.apache.thrift.protocol.TProtocol, struct:testMethod_args) {
        val prot:org.apache.thrift.protocol.TTupleProtocol = iprot as org.apache.thrift.protocol.TTupleProtocol
        val incoming:java.util.BitSet = prot.readBitSet(1)
        if (incoming.get(0)) {
          struct.req = testOneRequest()
          struct.req?.read(iprot)
          struct.setReqIsSet(true)
        }
      }
    }


    companion object {
      private val STRUCT_DESC: org.apache.thrift.protocol.TStruct = org.apache.thrift.protocol.TStruct("testMethod_args");

      private val REQ_FIELD_DESC: org.apache.thrift.protocol.TField = org.apache.thrift.protocol.TField("req", org.apache.thrift.protocol.TType.STRUCT, 1)

      private val STANDARD_SCHEME_FACTORY: org.apache.thrift.scheme.SchemeFactory<testMethod_argsStandardScheme> = testMethod_argsStandardSchemeFactory()
      private val TUPLE_SCHEME_FACTORY: org.apache.thrift.scheme.SchemeFactory<testMethod_argsTupleScheme> = testMethod_argsTupleSchemeFactory()
      // isset id assignments
      private fun <S : org.apache.thrift.TBase<S, *>> scheme(proto:org.apache.thrift.protocol.TProtocol): org.apache.thrift.scheme.IScheme<S> {
        if(proto.scheme.isAssignableFrom(org.apache.thrift.scheme.StandardScheme::class.java)) {
          return STANDARD_SCHEME_FACTORY.getScheme() as org.apache.thrift.scheme.IScheme<S>
        }
        return TUPLE_SCHEME_FACTORY.getScheme() as org.apache.thrift.scheme.IScheme<S>
      }
    }
  }

  class testMethod_result( 
    private var success: testOneResponse? = testOneResponse(), // required
    private var error: unsupportedName? = unsupportedName() // required
): org.apache.thrift.TBase<testMethod_result, testMethod_result.Fields>, java.io.Serializable, Cloneable, Comparable<testMethod_result>   {

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    enum class Fields(
      override val thriftFieldId: Short,
      override val fieldName: String
    ) : org.apache.thrift.TFieldIdEnum {
      SUCCESS(0, "success"),
      ERROR(1, "error");

      companion object {
        var byName: Map<String, Fields> = mapOf(
          "success" to SUCCESS,
          "error" to ERROR
        )
        /**
         * Find the Fields constant that matches fieldId, or null if its not found.
         */
        fun findByThriftId(fieldId: Short): Fields? {
          return when(fieldId) {
            (0).toShort() -> // SUCCESS
              SUCCESS
            (1).toShort() -> // ERROR
              ERROR
            else ->
              null
          }
        }

        /**
         * Find the Fields constant that matches fieldId, throwing an exception
         * if it is not found.
         */
        fun findByThriftIdOrThrow(fieldId: Short): Fields {
          return findByThriftId(fieldId)
            ?: throw java.lang.IllegalArgumentException("Field $fieldId doesn't exist!");
        }

        /**
         * Find the Fields constant that matches name, or null if its not found.
         */
        fun findByName(name: String): Fields? {
          return byName.get(name)
        }
      }
    }

      private val metaDataMap: Map<Fields, org.apache.thrift.meta_data.FieldMetaData> = mapOf(
        Fields.SUCCESS to org.apache.thrift.meta_data.FieldMetaData("success", org.apache.thrift.TFieldRequirementType.DEFAULT, 
            org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, testOneResponse::class.java)),
        Fields.ERROR to org.apache.thrift.meta_data.FieldMetaData("error", org.apache.thrift.TFieldRequirementType.DEFAULT, 
            org.apache.thrift.meta_data.StructMetaData(org.apache.thrift.protocol.TType.STRUCT, unsupportedName::class.java)))
      init {
        org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(testMethod_result::class.java, metaDataMap)
      }
    /**
     * Performs a deep copy on <i>other</i>.
     */
    constructor(other: testMethod_result) : this() {
      if (other.isSetSuccess()) {
        this.success = testOneResponse(other.success!!)
      }
      if (other.isSetError()) {
        this.error = unsupportedName(other.error!!)
      }
    }

    override fun deepCopy(): testMethod_result{
      return testMethod_result(this)
    }

    override fun clear() {
      this.success?.clear()
      this.error = null
    }

    fun getSuccess():testOneResponse? {
      return this.success
    }

    fun setSuccess(success: testOneResponse?): testMethod_result {
      this.success = success
      return this
    }

    fun unsetSuccess() {
      this.success = null
    }

    /** Returns true if field success is set (has been assigned a value) and false otherwise */
    fun isSetSuccess(): Boolean {
      return this.success != null
    }

    fun setSuccessIsSet(value: Boolean) {
      if (!value) {
        this.success = null
      }
    }

    fun getError():unsupportedName? {
      return this.error
    }

    fun setError(error: unsupportedName?): testMethod_result {
      this.error = error
      return this
    }

    fun unsetError() {
      this.error = null
    }

    /** Returns true if field error is set (has been assigned a value) and false otherwise */
    fun isSetError(): Boolean {
      return this.error != null
    }

    fun setErrorIsSet(value: Boolean) {
      if (!value) {
        this.error = null
      }
    }

    override fun setFieldValue(field: Fields,  value: Any?) {
        when (field) {
      Fields.SUCCESS ->
        if (value == null) {
          unsetSuccess()
        } else {
          setSuccess(value as testOneResponse)
        }

      Fields.ERROR ->
        if (value == null) {
          unsetError()
        } else {
          setError(value as unsupportedName)
        }

        }
    }

    override fun getFieldValue(field: Fields): Any? {
      return when(field) {
        Fields.SUCCESS -> getSuccess()
        Fields.ERROR -> getError()
      }
    }

    // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
    override fun isSet(field: Fields): Boolean {
      return when (field) {
        Fields.SUCCESS->isSetSuccess()
        Fields.ERROR->isSetError()
      }
    }

    override fun equals(other: Any?): Boolean {
      if (other is testMethod_result)
            return this.equals(other)
      return false
    }

    fun equals(other: testMethod_result?):Boolean {
      if (other == null)
        return false
      if (this == other)
        return true

      val this_present_success: Boolean = true && this.isSetSuccess()
      val other_present_success: Boolean = true && other.isSetSuccess()
      if (this_present_success || other_present_success) {
        if (!(this_present_success && other_present_success))
          return false;
        if (!this.success!!.equals(other.success))
          return false;
      }

      val this_present_error: Boolean = true && this.isSetError()
      val other_present_error: Boolean = true && other.isSetError()
      if (this_present_error || other_present_error) {
        if (!(this_present_error && other_present_error))
          return false;
        if (!this.error!!.equals(other.error))
          return false;
      }

      return true;
    }

    override fun hashCode():Int {
      var hashCode: Int = 1

      hashCode = hashCode * 8191 + (if(isSetSuccess()) 131071 else 524287)
      if (isSetSuccess())
        hashCode = hashCode * 8191 + success.hashCode()

      hashCode = hashCode * 8191 + (if(isSetError()) 131071 else 524287)
      if (isSetError())
        hashCode = hashCode * 8191 + error.hashCode()

      return hashCode
    }

    override fun compareTo(other: testMethod_result):Int {
      if (!javaClass.equals(other.javaClass)) {
        return javaClass.getName().compareTo(other.javaClass.getName())
      }

      var lastComparison:Int = 0

      lastComparison = java.lang.Boolean.compare(isSetSuccess(), other.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = java.lang.Boolean.compare(isSetError(), other.isSetError());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetError()) {
        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.error, other.error);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    override fun fieldForId(fieldId: Short):Fields? {
      return Fields.findByThriftId(fieldId)
    }

    override suspend fun read(iprot: org.apache.thrift.protocol.TProtocol) {
      scheme<testMethod_result>(iprot).read(iprot, this)
    }

    override suspend fun write(oprot: org.apache.thrift.protocol.TProtocol) {
      scheme<testMethod_result>(oprot).write(oprot, this)
    }

    override fun toString():String {
      val sb:java.lang.StringBuilder = java.lang.StringBuilder("testMethod_result(")
      var first:Boolean = true

      sb.append("success:")
      if (this.success == null) {
        sb.append("null")
      } else {
        sb.append(this.success)
      }
      first = false
      if (!first) sb.append(", ")
      sb.append("error:")
      if (this.error == null) {
        sb.append("null")
      } else {
        sb.append(this.error)
      }
      first = false
      sb.append(")");
      return sb.toString()
    }

    fun validate() {
      // check for required fields
      // check for sub-struct validity
      success?.validate();
    }

    suspend fun writeObject(out:java.nio.channels.AsynchronousByteChannel) {
      try {
        write(org.apache.thrift.protocol.TCompactProtocol(org.apache.thrift.transport.TIOStreamTransport(out)))
      } catch (te:org.apache.thrift.TException) {
        throw java.io.IOException(te);
      }
    }

    suspend fun readObject(inp:java.nio.channels.AsynchronousByteChannel) {
      try {
        read(org.apache.thrift.protocol.TCompactProtocol(org.apache.thrift.transport.TIOStreamTransport(inp)))
      } catch (te:org.apache.thrift.TException) {
        throw java.io.IOException(te);
      }
    }

    private class testMethod_resultStandardSchemeFactory : org.apache.thrift.scheme.SchemeFactory<testMethod_resultStandardScheme> {
      override fun getScheme():testMethod_resultStandardScheme {
        return testMethod_resultStandardScheme()
      }
    }

    private class testMethod_resultStandardScheme : org.apache.thrift.scheme.StandardScheme<testMethod_result>() {

      override suspend fun read(iprot:org.apache.thrift.protocol.TProtocol, struct:testMethod_result) {
        lateinit var schemeField: org.apache.thrift.protocol.TField
        iprot.readStructBegin();
        while (true)
        {
          schemeField = iprot.readFieldBegin()
          if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
            break
          }
          when (schemeField.id.toInt()) {
            0 -> // SUCCESS
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.success = testOneResponse()
                struct.success?.read(iprot)
                struct.setSuccessIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
            1 -> // ERROR
              if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {
                struct.error = unsupportedName()
                struct.error?.read(iprot)
                struct.setErrorIsSet(true);
              } else { 
                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
              }
            else ->
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
          }
          iprot.readFieldEnd();
        }
        iprot.readStructEnd();

        // check for required fields of primitive type, which can't be checked in the validate method
        struct.validate();
      }

      override suspend fun write(oprot:org.apache.thrift.protocol.TProtocol, struct:testMethod_result) {
        struct.validate()

        oprot.writeStructBegin(STRUCT_DESC)
        if (struct.success != null) {
          oprot.writeFieldBegin(SUCCESS_FIELD_DESC)
          struct.success?.write(oprot);
          oprot.writeFieldEnd()
        }
        if (struct.error != null) {
          oprot.writeFieldBegin(ERROR_FIELD_DESC)
          struct.error?.write(oprot);
          oprot.writeFieldEnd()
        }
        oprot.writeFieldStop()
        oprot.writeStructEnd()
      }

    }

    private class testMethod_resultTupleSchemeFactory : org.apache.thrift.scheme.SchemeFactory<testMethod_resultTupleScheme> {
      override fun getScheme():testMethod_resultTupleScheme {
        return testMethod_resultTupleScheme()
      }
    }

    private class testMethod_resultTupleScheme : org.apache.thrift.scheme.TupleScheme<testMethod_result>() {

      override suspend fun write(oprot:org.apache.thrift.protocol.TProtocol, struct:testMethod_result) {
        val prot:org.apache.thrift.protocol.TTupleProtocol = oprot as org.apache.thrift.protocol.TTupleProtocol
        val optionals:java.util.BitSet = java.util.BitSet()
        if (struct.isSetSuccess()) {
          optionals.set(0)
        }
        if (struct.isSetError()) {
          optionals.set(1)
        }
        prot.writeBitSet(optionals, 2)
        if (struct.isSetSuccess()) {
          struct.success?.write(oprot);
        }
        if (struct.isSetError()) {
          struct.error?.write(oprot);
        }
      }

      override suspend fun read(iprot: org.apache.thrift.protocol.TProtocol, struct:testMethod_result) {
        val prot:org.apache.thrift.protocol.TTupleProtocol = iprot as org.apache.thrift.protocol.TTupleProtocol
        val incoming:java.util.BitSet = prot.readBitSet(2)
        if (incoming.get(0)) {
          struct.success = testOneResponse()
          struct.success?.read(iprot)
          struct.setSuccessIsSet(true)
        }
        if (incoming.get(1)) {
          struct.error = unsupportedName()
          struct.error?.read(iprot)
          struct.setErrorIsSet(true)
        }
      }
    }


    companion object {
      private val STRUCT_DESC: org.apache.thrift.protocol.TStruct = org.apache.thrift.protocol.TStruct("testMethod_result");

      private val SUCCESS_FIELD_DESC: org.apache.thrift.protocol.TField = org.apache.thrift.protocol.TField("success", org.apache.thrift.protocol.TType.STRUCT, 0)
      private val ERROR_FIELD_DESC: org.apache.thrift.protocol.TField = org.apache.thrift.protocol.TField("error", org.apache.thrift.protocol.TType.STRUCT, 1)

      private val STANDARD_SCHEME_FACTORY: org.apache.thrift.scheme.SchemeFactory<testMethod_resultStandardScheme> = testMethod_resultStandardSchemeFactory()
      private val TUPLE_SCHEME_FACTORY: org.apache.thrift.scheme.SchemeFactory<testMethod_resultTupleScheme> = testMethod_resultTupleSchemeFactory()
      // isset id assignments
      private fun <S : org.apache.thrift.TBase<S, *>> scheme(proto:org.apache.thrift.protocol.TProtocol): org.apache.thrift.scheme.IScheme<S> {
        if(proto.scheme.isAssignableFrom(org.apache.thrift.scheme.StandardScheme::class.java)) {
          return STANDARD_SCHEME_FACTORY.getScheme() as org.apache.thrift.scheme.IScheme<S>
        }
        return TUPLE_SCHEME_FACTORY.getScheme() as org.apache.thrift.scheme.IScheme<S>
      }
    }
  }

}
